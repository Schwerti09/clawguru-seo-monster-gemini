// lib/agents/cve-agent.ts
// Gemini-powered CVE content generator for /solutions/fix-[cve_id] pages.

import type { CveEntry } from "@/lib/cve-pseo"

/** Call Gemini API and return the raw text response, or null on failure */
async function callGemini(prompt: string): Promise<string | null> {
  const geminiKey = process.env.GEMINI_API_KEY
  const geminiModel = process.env.GEMINI_MODEL || "gemini-1.5-flash"
  const geminiBase = (
    process.env.GEMINI_BASE_URL || "https://generativelanguage.googleapis.com/v1beta"
  ).replace(/\/$/, "")

  if (!geminiKey) return null

  try {
    const url = `${geminiBase}/models/${encodeURIComponent(geminiModel)}:generateContent?key=${encodeURIComponent(geminiKey)}`
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        generationConfig: { temperature: 0.4, maxOutputTokens: 2000 },
      }),
      signal: AbortSignal.timeout(30_000),
    })
    if (!res.ok) return null
    const data = await res.json()
    const parts = data?.candidates?.[0]?.content?.parts
    if (Array.isArray(parts)) {
      return parts.map((p: { text?: string }) => p?.text ?? "").join("").trim() || null
    }
    return null
  } catch {
    return null
  }
}

export type CveAiContent = {
  /** Unique AI-generated intro paragraph for the CVE page */
  introHtml: string
  /** What is this vulnerability? – for the H2 section */
  whatIsHtml: string
  /** Impact and risks – for the H3 section */
  impactHtml: string
  /** Extended mitigation detail text */
  mitigationDetail: string
  /** Was this generated by AI? */
  aiGenerated: boolean
}

/** Build fallback content from static CveEntry data when Gemini is unavailable */
function buildFallbackContent(entry: CveEntry): CveAiContent {
  return {
    introHtml: `${entry.cveId} (${entry.name}) is a <strong>${entry.severity.toUpperCase()} severity</strong> vulnerability with a CVSS score of ${entry.cvssScore}/10. ${entry.description} Follow the step-by-step guide below to remediate this vulnerability in your infrastructure.`,
    whatIsHtml: `${entry.name} (${entry.cveId}) affects <strong>${entry.affectedSoftware}</strong>. ${entry.description} It was published on ${entry.publishedDate} and affects <strong>${entry.affectedVersions}</strong>. The fixed version is <strong>${entry.fixedVersions}</strong>.`,
    impactHtml: entry.impactSummary,
    mitigationDetail: `To remediate ${entry.cveId}, follow the prioritized mitigation steps: ${entry.mitigationSteps.join(" → ")}. Verify the fix using the verification commands below and confirm the patched version is deployed across all affected systems.`,
    aiGenerated: false,
  }
}

/**
 * Generate unique AI content for a CVE solution page using Gemini.
 * Falls back to static content if Gemini is unavailable.
 */
export async function generateCveContent(entry: CveEntry): Promise<CveAiContent> {
  const prompt = [
    "You are a senior security engineer writing SEO-optimized content for a CVE vulnerability fix page.",
    "Write concise, technical, and actionable content for the following CVE.",
    "Return ONLY a JSON object with these exact keys:",
    "  introHtml: string — 2-3 sentence intro about the CVE (plain text, no HTML tags)",
    "  whatIsHtml: string — 3-4 sentence technical explanation of what the vulnerability is (plain text)",
    "  impactHtml: string — 2-3 sentence description of business and infrastructure impact (plain text)",
    "  mitigationDetail: string — 2-3 sentence paragraph on how to apply the fix and verify it (plain text)",
    "",
    "CVE details:",
    `  CVE ID: ${entry.cveId}`,
    `  Name: ${entry.name}`,
    `  Affected Software: ${entry.affectedSoftware}`,
    `  Severity: ${entry.severity} (CVSS ${entry.cvssScore})`,
    `  Published: ${entry.publishedDate}`,
    `  Affected Versions: ${entry.affectedVersions}`,
    `  Fixed Version: ${entry.fixedVersions}`,
    `  Description: ${entry.description}`,
    `  Impact: ${entry.impactSummary}`,
    "",
    "Keep each field under 300 characters. Be technically accurate. No HTML tags in output.",
    "Do not add any text outside the JSON object.",
  ].join("\n")

  const text = await callGemini(prompt)
  if (!text) return buildFallbackContent(entry)

  try {
    const parsed = JSON.parse(text.replace(/```json|```/g, "").trim()) as Partial<CveAiContent>
    return {
      introHtml: parsed.introHtml || buildFallbackContent(entry).introHtml,
      whatIsHtml: parsed.whatIsHtml || buildFallbackContent(entry).whatIsHtml,
      impactHtml: parsed.impactHtml || buildFallbackContent(entry).impactHtml,
      mitigationDetail: parsed.mitigationDetail || buildFallbackContent(entry).mitigationDetail,
      aiGenerated: true,
    }
  } catch {
    return buildFallbackContent(entry)
  }
}
