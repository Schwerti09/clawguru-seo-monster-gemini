// WORLD BEAST UPGRADE: lib/agents/fix-agent.ts
// Automated Fix Code Generator – produces ready-to-use Docker, nginx, Terraform etc. code
// for any runbook slug, using Gemini AI.

// WORLD BEAST UPGRADE: Gemini helper (self-contained)
async function callGeminiFix(prompt: string): Promise<string | null> {
  const geminiKey = process.env.GEMINI_API_KEY
  const geminiModel = process.env.GEMINI_MODEL || "gemini-1.5-flash"
  const geminiBase = (
    process.env.GEMINI_BASE_URL || "https://generativelanguage.googleapis.com/v1beta"
  ).replace(/\/$/, "")

  if (!geminiKey) return null

  try {
    const url = `${geminiBase}/models/${encodeURIComponent(geminiModel)}:generateContent?key=${encodeURIComponent(geminiKey)}`
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        generationConfig: { temperature: 0.3, maxOutputTokens: 2500 },
      }),
      signal: AbortSignal.timeout(30_000),
    })
    if (!res.ok) return null
    const data = await res.json()
    const parts = data?.candidates?.[0]?.content?.parts
    if (Array.isArray(parts)) {
      return parts.map((p: { text?: string }) => p?.text ?? "").join("").trim() || null
    }
    return null
  } catch {
    return null
  }
}

export type FixFile = {
  filename: string
  language: string   // e.g. "dockerfile", "nginx", "terraform", "yaml", "bash"
  content: string
}

export type FixCodeResult = {
  slug: string
  title: string
  problemDescription: string
  solutionDescription: string
  severity: "critical" | "high" | "medium" | "low"
  estimatedTime: string  // e.g. "~10 minutes"
  files: FixFile[]
  testingSteps: string[]
  prTitle: string
  generatedAt: string
}

// WORLD BEAST UPGRADE: Fallback fix for when Gemini is unavailable
function fallbackFix(slug: string): FixCodeResult {
  const title = slug
    .replace(/-/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase())

  return {
    slug,
    title: `Fix: ${title}`,
    problemDescription: `This runbook addresses the ${title} issue commonly found in cloud infrastructure.`,
    solutionDescription: "Apply the provided configuration changes and follow the testing checklist.",
    severity: "medium",
    estimatedTime: "~15 minutes",
    files: [
      {
        filename: "docker-compose.fix.yml",
        language: "yaml",
        content: `# Fix for ${slug}\n# Generated by ClawGuru WorldBeast\nversion: "3.9"\nservices:\n  app:\n    restart: unless-stopped\n    healthcheck:\n      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]\n      interval: 30s\n      timeout: 10s\n      retries: 3`,
      },
      {
        filename: "nginx.fix.conf",
        language: "nginx",
        content: `# Fix for ${slug}\n# Generated by ClawGuru WorldBeast\nserver {\n  listen 443 ssl http2;\n  ssl_protocols TLSv1.2 TLSv1.3;\n  ssl_ciphers HIGH:!aNULL:!MD5;\n  add_header X-Content-Type-Options nosniff;\n  add_header X-Frame-Options DENY;\n  add_header Strict-Transport-Security "max-age=31536000" always;\n}`,
      },
    ],
    testingSteps: [
      "Backup existing configuration before applying changes",
      "Apply changes to staging environment first",
      "Run integration tests",
      "Monitor logs for 10 minutes after deployment",
      "Verify health check endpoints return 200",
    ],
    prTitle: `fix: resolve ${slug}`,
    generatedAt: new Date().toISOString(),
  }
}

/**
 * WORLD BEAST UPGRADE: generateFixCode()
 * Generates complete ready-to-use fix code for a runbook slug.
 * Uses Gemini when available, falls back to template-based code.
 */
export async function generateFixCode(slug: string): Promise<FixCodeResult> {
  const title = slug
    .replace(/-/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase())

  const prompt = [
    "You are the ClawGuru Automated Fix Code Generator 2026.",
    "Generate production-ready fix code for the following infrastructure issue:",
    "",
    `Issue slug: ${slug}`,
    `Issue title: ${title}`,
    "",
    "Generate practical fix code files (Docker, nginx, Terraform, Kubernetes YAML, or bash scripts as appropriate).",
    "Return ONLY a JSON object with these exact keys:",
    "  title: string — human-readable fix title (max 80 chars)",
    "  problemDescription: string — what causes this problem (max 200 chars)",
    "  solutionDescription: string — what the fix does (max 200 chars)",
    '  severity: "critical"|"high"|"medium"|"low"',
    '  estimatedTime: string — e.g. "~10 minutes"',
    "  files: Array<{ filename: string, language: string, content: string }> — 2-4 files",
    "  testingSteps: string[] — 4-6 testing/verification steps",
    "  prTitle: string — git commit / PR title",
    "",
    "Write real, production-quality code. Not pseudocode.",
    "Do not add explanations outside the JSON.",
  ].join("\n")

  const text = await callGeminiFix(prompt)

  if (!text) return fallbackFix(slug)

  try {
    const parsed = JSON.parse(text.replace(/```json|```/g, "").trim()) as Partial<FixCodeResult>
    return {
      slug,
      title: parsed.title || title,
      problemDescription: parsed.problemDescription || "",
      solutionDescription: parsed.solutionDescription || "",
      severity: parsed.severity || "medium",
      estimatedTime: parsed.estimatedTime || "~15 minutes",
      files: Array.isArray(parsed.files) && parsed.files.length > 0 ? parsed.files : fallbackFix(slug).files,
      testingSteps: Array.isArray(parsed.testingSteps) ? parsed.testingSteps : fallbackFix(slug).testingSteps,
      prTitle: parsed.prTitle || `fix: resolve ${slug}`,
      generatedAt: new Date().toISOString(),
    }
  } catch {
    return fallbackFix(slug)
  }
}
